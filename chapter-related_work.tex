\chapter{\label{cha:related}Related Work}

Related work falls into three categories: weak memory models, model checking and fuzzing.

\section{Fuzzing}

AFL\cite{afl} is a coverag guided grey-box fuzzer. The user program is intrumented with deputy functions at the entry of basicblocks evenly. The deputy functions can collect runtime information for code coverage analysis. AFL mutates the input for the program to cover new branches and execution paths. Since AFL is initially designed for sequential programs, which has deterministic results when the input and random seed are fixed, it is unaware of thread interleaving contexts.
AFLFast\cite{fuzz:aflfast} is an an extention of AFL, improving the efficiency and speed using power schedules. It incorporates search strategies that orders the seeds and controls their powers, i.e. the number of inputs generated by seeds, to reveal the low frequency paths.
FairFuzz\cite{fuzz:FairFuzz} is a coverage guided fuzzer based on AFL that improves the uniformity of covered code paths. It places fairness as the core criteria when generating seeds, preventing code paths being biasly explored.
MOPT\cite{fuzz:MOPT} proposes a automated parameter optimization approach to improve mutation based fuzzers. It implements a dynamic mutation scheduling strategy to optimize the parameter settings, such as probability distribution, for selecting mutation operators.
Angora\cite{fuzz:Angora} is a coverage guided fuzzer that aims to increase the branch coverage. It improves mutation based fuzzing, which is more difficult to generate high quality seeds than symbolic execution, by dynamically tracking program execution and counting branches to solve constraints for different paths, guiding the generation of seeds in later executions.
SlowFuzz\cite{fuzz:SlowFuzz} is aimed at algorithmic complexity vulnerabilities, which are triggered when user input causes the program to exhibit worst-case algorithmic behaviors. It searches worst-case inputs using the binary
Muzz\cite{muzz} thread-aware grey-box fuzzing tool for multithreaded programs. Instead of instrument the user program evenly, Muzz conducts static analysis first to locate set of specific program statements on which thread-interleavings may only happen, identified as suspicious interleaving scopes. Then Muzz will instrument more deputy instructions inside these scopes. During repeated execution, the inserted functions can collect thread context information, hence the fuzzer is able to select interesting seeds that triggered unique thread interleavings.
Conzzer\cite{conzzer} is a context-sensitive and directional concurrency fuzzing tool for data-race detection. It is motivated by the fact that some concurrent bugs only happen when two specific functions with callstacks are executed concurrently. Conzzer uses context sensitive concurrent function call pairs as the mutation target.
Krace\cite{fuzz:Krace} fuzzes against data races in kernel file systems. It sets the coverage metric at the concurrency dimension, generating and mutating syscall sequences to detect possible data races, using a race detector based on lockset and happens-before relations.
Razzer\cite{fuzz:Razzer} applies the static analysis technique to guide the fuzzer to reach potential racy states. It uses controlled scheduling generate deterministic executions, by enforcing certain thread interleavings.
RFF\cite{rff} uses the reads-from pairs as seeds to explore thread schedules for bug detection. It analyze program executions using abstract schedules to identify interesting seeds.





\section{Model Checking}

As the complexity of software systems grows, the demand for checking their correctness and robustness also increases. In 1986, Clarke and Emerson \cite{mc:Clarke} proposed a automated verification approach for finite state concurrent systems satisfying some certain temporal logic specifications. Due to its efficiency over manually proving, model checking has been widely applied in various domains, including computer architecture, control systems, concurrent software and communication protocols.
SPIN\cite{mc:spin} is a model checker that formally verifies concurrent and distributed systems. It uses a domain specific language, called Promela, to describe the models, with the properties checked written in assertions or linear temporal logic formulas.
SMV\cite{mc:smv} is a symbolic model checking tool for verifying finite state space systems. It uses the specialized modeling language, named SMV, to model the system behaviors. It uses boolean formulas instead of state graphs to verify the programs with the help of binary decision diagram manipulations.
NuSMV\cite{mc:NuSMV} is a reimplementation and enhanced version of SMV. It inherits most of the basic functionalities of SMV with a number of extentions. It is developed for improving the scalability and flexibility of SMV.
PRISM\cite{mc:PRISM} is a problisitic model checker supporting Markov chains and Markov Decision Processes, modeling the undeterministic system behaviors. The tool provides both symbolic model checking based on binary decision diagrams and sparse matrices based model checking. It can be used for checking a wide range of applications, such as internet protocols, embedded systems and biological systems.
CDSchecker\cite{cdschecker} is an exhaustive model checker exploring the behaviors of concurrent code under the original C/C++11 memory model based on stateless model-checking. A technique of constraint-based treatment of modification order is introduced remove redundancy from the search space. A cycle in the modification order graph corresponds to infeasibility of the constraints. CDSchecker uses depth-first search to check for cycles by adding edges to the modification order graph and rolls back when the constraints are unsatisfiable. The scalability limits and memory model support are extended by the C11Tester.
CBMC\cite{mc:CBMC} is a bounded model checker for C and C++ programs. It verifies memory safety problems, undefined behaviours and assertion failures. It bounds the searching space of programs by bounding the number of iteration for loops, limiting the length of execution paths and restricting the variable values, etc.
GenMC \cite{genmc} is a stateless model checker for C/C++ programs under weak memory models. It suports a variety of memory models such as  RC11, IMM, and LKMM, and is extendable for  further axiomatic memory models. The program is compiled into LLVM-IR for incorporating optimizations including symmetry reduction and lock-aware partial order reduction, making it possible to support different programming languages provided that its memory model is axiomatic well defined.
Civl\cite{mc:civl} is a formal verification tool for concurrent programs, supporting C, C++ and Java. It staticly analyzes the program and perform a sequence of transformations that simplifies the program based on its internal invariants.
PAT\cite{mc:PAT} is a framework used for automated system analysis based on process algebra CSP. It can be used for verifying systems such as concurrent systems, real-time systems, network service models and probabilistic systems. It verifies system properties including deadlock freedom, liveness, LTL properties and can perform probabilistic model checking.



% \lipsum{2} % add some pseudo content

% \section{Related part II}

% \lipsum{4} % add some pseudo content 

% \section{Related part III}

% \lipsum{1} % add some pseudo content


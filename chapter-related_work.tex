\chapter{\label{cha:related}Related Work}

Related work falls into three categories: weak memory models, model checkers and fuzzers. 

% memory model

The initial proposal for the C/C++11 memory model was made in 2008\cite{c++model-proposal}. In this proposal, the memory model is described in prose style, resulting in ambiguity and verbosity. In 2011, a formal and mathematized version was proposed, using the 




AFL\cite{afl} is a coverag guided grey-box fuzzer. The user program is intrumented with deputy functions at the entry of basicblocks evenly. The deputy functions can collect runtime information for code coverage analysis. AFL mutates the input for the program to cover new branches and execution paths. Since AFL is initially designed for sequential programs, which has deterministic results when the input and random seed are fixed, it is unaware of thread interleaving contexts. 

Muzz\cite{muzz} thread-aware grey-box fuzzing tool for multithreaded programs. Instead of instrument the user program evenly, Muzz conducts static analysis first to locate set of specific program statements on which thread-interleavings may only happen, identified as suspicious interleaving scopes. Then Muzz will instrument more deputy instructions inside these scopes. During repeated execution, the inserted functions can collect thread context information, hence the fuzzer is able to select interesting seeds that triggered unique thread interleavings. 

Conzzer\cite{conzzer} is a context-sensitive and directional concurrency fuzzing tool for data-race detection. It is motivated by the fact that some concurrent bugs only happen when two specific functions with callstacks are executed concurrently. Conzzer uses context sensitive concurrent function call pairs as the mutation target. 



 

C11Tester \cite{c11tester} is a race detector for the C/C++ memory model. It supports concurrency primitives and the weak memory behaviors allowed by the C/C++20 standard. A constraint-based algorithm is proposed to explore the modification order graph. Under the memory model constraints, decisions are made randomly when generating possible thread interleavings and atomic operation behaviors. During repeated execution, execution graphs are generated independantly without feedback information from previous iterations by default. However, C11Tester provides a plugable framework that allows for selecting the next thread and behavior from a set of legal choices.   





\section{Model Checking}

As the complexity of software systems grows, the demand for checking their correctness and robustness also increases. In 1986, Clarke and Emerson \cite{mc:Clarke} proposed a automated verification approach for finite state concurrent systems satisfying some certain temporal logic specifications. Due to its efficiency over manually proving, model checking has been widely applied in various domains, including computer architecture, control systems, concurrent software and communication protocols. 
SPIN\cite{mc:spin} is a model checker that formally verifies concurrent and distributed systems. It uses a domain specific language, called Promela, to describe the models, with the properties checked written in assertions or linear temporal logic formulas. 
SMV\cite{mc:smv} is a symbolic model checking tool for verifying finite state space systems. It uses the specialized modeling language, named SMV, to model the system behaviors. It uses boolean formulas instead of state graphs to verify the programs with the help of binary decision diagram manipulations. 
NuSMV\cite{mc:NuSMV} is a reimplementation and enhanced version of SMV. It inherits most of the basic functionalities of SMV with a number of extentions. It is developed for improving the scalability and flexibility of SMV.
PRISM\cite{mc:PRISM} is a problisitic model checker supporting Markov chains and Markov Decision Processes, modeling the undeterministic system behaviors. The tool provides both symbolic model checking based on binary decision diagrams and sparse matrices based model checking. It can be used for checking a wide range of applications, such as internet protocols, embedded systems and biological systems. 
CDSchecker\cite{cdschecker} is an exhaustive model checker exploring the behaviors of concurrent code under the original C/C++11 memory model based on stateless model-checking. A technique of constraint-based treatment of modification order is introduced remove redundancy from the search space. A cycle in the modification order graph corresponds to infeasibility of the constraints. CDSchecker uses depth-first search to check for cycles by adding edges to the modification order graph and rolls back when the constraints are unsatisfiable. The scalability limits and memory model support are extended by the C11Tester. 
CBMC\cite{mc:CBMC} is a bounded model checker for C and C++ programs. It verifies memory safety problems, undefined behaviours and assertion failures. It bounds the searching space of programs by bounding the number of iteration for loops, limiting the length of execution paths and restricting the variable values, etc. 
GenMC \cite{genmc} is a stateless model checker for C/C++ programs under weak memory models. It suports a variety of memory models such as  RC11, IMM, and LKMM, and is extendable for  further axiomatic memory models. The program is compiled into LLVM-IR for incorporating optimizations including symmetry reduction and lock-aware partial order reduction, making it possible to support different programming languages provided that its memory model is axiomatic well defined. 
Civl\cite{mc:civl} is a formal verification tool for concurrent programs, supporting C, C++ and Java. It staticly analyzes the program and perform a sequence of transformations that simplifies the program based on its internal invariants. 
PAT\cite{mc:PAT} is a framework used for automated system analysis based on process algebra CSP. It can be used for verifying systems such as concurrent systems, real-time systems, network service models and probabilistic systems. It verifies system properties including deadlock freedom, liveness, LTL properties and can perform probabilistic model checking.


 
% \lipsum{2} % add some pseudo content

% \section{Related part II}

% \lipsum{4} % add some pseudo content 
   
% \section{Related part III}

% \lipsum{1} % add some pseudo content


\chapter{\label{cha:intro}Introduction}

% testing

To address the threat posed by bugs or vulnerability of programs, researchers have investigated varieties of bug detection techniques. Formal verification techniques such as axiomatic approaches use mathematical deduction to prove whether a safety property is guaranteed. Such approaches heavily rely on the expertise of developers and normally require huge amount of time and effort. % \cite{}
Automated testing, on the other hand, has for long been of great importance for its scalability and efficiency. Testing techniques aimed at discovering bugs and safety vulnerabilities have been developed over the years, primarily including static analysis and dynamic testing. Static analysis tools typically performs bug detection at compile time, relying on some abstraction of the semantics of the source code. % \cite{}
Due to the complexity of the programming language and the logic of the tested program, such static analysis tools sometimes do not ensure reporting bugs comprehensively and correctly. The other way is dynamic testing, which explores reachable states at runtime. Unit testing, for example, plays a fundamental role in software development. Some influential tools have been developed, including AddressSanitizer, detecting addressability issues, and ThreadSanitizer, which detects data races and deadlocks. However, even though high quality test cases can cover large ranges of program behaviors, there can still be some corner cases that are not exposed. In addition, such test cases require a deep understanding of the program under test and consumes a considerable amount of time and effort to complete. 

% fuzzing

Fuzz testing has become increasingly popular in recent years. It repeatedly executes the tested program by generating random inputs and monitors whether any buggy behaviors are observed. This type of approaches are usually easy to apply and have good scalability. One of the most significant fuzzing tool is AFL, a coverage-guided mutation-based grey-box fuzzer. AFL performs compile-time instrumentation and uses the coverage of the control flow edges as the feedback information for generating new seeds, thus achieving superior efficiency than previous black-box fuzzers. Researchers have developed various techniques to improve the code coverage and accelerate the bug detection. % \cite{}

A fuzzer typically has a feedback loop. It starts with a seed, or program input, and execute the instrumented program with the seed. The information about the execution is collected to determine whether a seed is interesting, which means the seed has triggered new interested behaviors. The interesting seeds will be used for generating new seeds during repeated executions. A mutation-based fuzzer can mutate (such as bit flipping, hashing, shifting, etc) the interesting seeds to generate new seeds. 

% concurrency

Entering the multi-core era, concurrent programming has gain increasing significance. Fuzzing for concurrent programs also attracts interests from researchers. Traditional coverage-guided approaches can face challenges when detecting concurrency bugs, since the code coverage information does not reflect the thread interleavings, some of which may result in concurrency bugs. Therefore, thread-relevant instrumentation is needed for providing concurrency feedback information in the fuzzing loop. Another problem is that, assuming sequential consistency, both the program input and the thread interleavings (or schedules) determine the program's behavior. Given a seed, the bugs that only happen along with infrequent thread-interleavings may not be easy to reveal during repeated execution. 

% weak memory
















\section{Terminology}

The term \emph{reverse engineering} is defined by Chikofsky and Cross as 
``\emph{The process of analyzing a subject system with two goals in mind: 
(1) to identify the system's components and their interrelationships; and,
(2) to create representations of the system in another form or at a higher 
level of abstraction}'' \cite{c11tester}.

Note that this Terminology section is not a required section but 
merely an example.

\section{Research Question(s)}

The research question investigated in this thesis is \ldots

\lipsum{10} % add some pseudo content

